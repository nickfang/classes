Hi again!  The good news is that if you've made it this far, you should (I hope!) now have a basic understanding of regular expressions, and where/how they can be helpful.  I hope that you've done a bunch (or even all ) of the exercises, and that you've explored how your favorite programming languages can interface with regexps.

More importantly, I hope that you now have a good sense of where regexps can help you (and where they can't).  But of course, we've only scratched the surface of what's possible with regexps.  In this message, I'm going to describe, in rapid succession, a number of more advanced regexp ideas that are extremely useful, but which you should probably wait to learn and understand until you've gotten a bit more experience under your belt.  That said, if you find yourself in need of a certain feature, you now have the foundational knowledge necessary to build upon it and learn more yourself.

I should note that not all of these features are available in every regexp engine.  Part of learning regexps is (unfortunately) also learning to work with them, and to figure out which capabilities your specific dialect and implementation includes.  Is that frustrating?  Oh, of course... and then, you can sometimes be fortunate enough to work with a language that has an alternative regexp library (as are available for JavaScript and Python).

So, What are the more advanced features of regexps that you should know about?  Here, in no specific order, I'll list them:
	- Non-greedy: Regexp operators are greedy, which means that they match the maximum number of possible characters.  Sometimes, though, you want them to match the minimum number.  In order to do that, you'll want to make them non-greedy, typically by putting a "?" after the previous character.  So "a+" matches the maximum number of "a" characters in a row, and "a+?" matches the minimum number of characters in a row.
	- Backreferences: Sometimes, you want to match the same thing twice — meaning, you want to match the first two letters of a word and then the last two letters of that same word, and you want them to be the same.  You can do this with "backreferences," in which you say, "I want to match whatever was in group #1."  The syntax for backreferences can be a bit tricky, not just because the idea can sometimes drive people a bit batty, but also because every language deals with them in a slightly different way.
	- Lookahead and lookbehind: On some occasions, you want to find text within a certain context. Lookbehind allows you to indicate that a certain pattern occurs before the pattern in which you're interested, without consuming characters or moving the regexp engine's pointer. Lookahead allows you to the same, but with an eye toward characters that come after the regexp that's of interest to us. And of course, we have both positive and negative versions of each of these. Lookahead and lookbehind are useful in a small number of cases — but when they're useful, they are very useful.
	- Non-capturing parentheses: If you want to use parentheses to group characters into a pattern that is matched by ?, +, *, or {min,max}, but don't want to have that group be counted among the numbered groups captured by the regexp, you can define the group to be "non-capturing."  This is something that I normally do only if I have an existing, complex regexp and don't feel like renumbering all of the groups that were defined and used elsewhere.
	- Named groups: If you have a complex regexp, then using numbered groups can turn out to be a bit annoying.  Fortunately, many regexp engines allow us to specify group names, rather than accept the default, which is numbers.  This isn't very portable across regexp libraries or programming languages, but is used in (for example) the Django Web-development framework for Python.  Named groups are used by Django to pass parameters to functions that handle HTTP requests.
	- Options: Every regexp library provides options. In some cases, these redefine "." to match all characters (including newlines).  Or that ^ and $ should work ona  per-row basis, rather than on the entire screen.  Or that we're performing  global search.  Or that we want to let our regexp contain newlines and whitespace for additional readability.  Whatever the reason, every regexp system has its own exceptions and modifiers, which means learning something new and specific with each language.

There are many more differences between regexp engines, but this is a good start.  Again, these topics are fairly advanced, and while you should aim to learn them all, it'll take time to do so.  Use the basics that you have learned in this course so far, and that will get you very close to what you need for your day-to-day work.

That's about it!  I'll be back tomorrow with a summary and some additional resources.

Reuven